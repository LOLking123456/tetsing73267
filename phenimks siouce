
























































































































local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/Mapple7777/UI-Librarys/main/UI-1/UI.lua"))()

local Window = Library:Create("Legend Handles","Phenom")

local Tab1 = Window:Tab("Main",true)

Tab1:Label("Made By Legend Handles On Youtube!")

Tab1:Button("Aimbot",function()
    local Player = game.Players.LocalPlayer
local Camera = workspace.CurrentCamera
Holding = false
e = false
isdoing = false
function findGoals()
for i, v in pairs(workspace:GetDescendants()) do
if v.Name == 'Goal' then
v.Parent = workspace
end
end
end
local function findClosestPart(position)
   local closestPart, closestPartMagnitude
   local tmpMagnitude
   for i, v in pairs(workspace:GetChildren()) do
       if v.Name == 'Goal' then
           if closestPart then
               tmpMagnitude = (position - v.Position).magnitude
               if tmpMagnitude < closestPartMagnitude then
                   closestPart = v
                   closestPartMagnitude = tmpMagnitude
               end
           else
               closestPart = v
               closestPartMagnitude = (position - v.Position).magnitude
           end
       end
   end
   return closestPart
end
--//vb
local player = game.Players.LocalPlayer
local camera = game.Workspace.CurrentCamera
local character = player.Character
local head = character.Head
local torso = character.Torso
findGoals()
local function cam()
   while wait() do
       if isdoing == true then
         local pos = head.Position
     local partyGoal = findClosestPart(head.Position)
     local lookAt = partyGoal.Position + Vector3.new(0,90,0)
     local mag = (character.PrimaryPart.Position - partyGoal.Position).magnitude
     local cameraCFrame = CFrame.new(pos, lookAt)
     Camera.CFrame = cameraCFrame
     else
         return nil
     end
   end
   end

game.Players.LocalPlayer.Character.ChildAdded:Connect(function(child)
local pv = game.Players.LocalPlayer.Character.Basketball
local UIS = game:GetService('UserInputService')

game.Players.LocalPlayer.Character:WaitForChild("Humanoid").Jumping:Connect(function()
    isdoing = true
    if game.Players.LocalPlayer.Character.Basketball then
           local lookthat = findClosestPart(game.Players.LocalPlayer.Character.Torso.Position)
       local pvm = (lookthat.Position - game.Players.LocalPlayer.Character.Torso.Position).magnitude
       if pvm >= 30  then
           if pvm <=44 then
               pv.PowerValue.Value = 75
              cam()
         end
       end
           local lookthat = findClosestPart(game.Players.LocalPlayer.Character.Torso.Position)
       local pvm = (lookthat.Position - game.Players.LocalPlayer.Character.Torso.Position).magnitude
       if pvm >= 45  then
           if pvm <=53 then
               pv.PowerValue.Value = 80
              cam()
         end
       end
local lookthat = findClosestPart(game.Players.LocalPlayer.Character.Torso.Position)
       local pvm = (lookthat.Position - game.Players.LocalPlayer.Character.Torso.Position).magnitude
       if pvm >= 54  then
           if pvm <=66 then
                pv.PowerValue.Value = 85
              cam()
       
         end
       end
           local lookthat = findClosestPart(game.Players.LocalPlayer.Character.Torso.Position)
       local pvm = (lookthat.Position - game.Players.LocalPlayer.Character.Torso.Position).magnitude
       if pvm >= 67  then
           if pvm <=76 then
pv.PowerValue.Value = 90
              cam()
                 
       
         end
end
           local lookthat = findClosestPart(game.Players.LocalPlayer.Character.Torso.Position)
       local pvm = (lookthat.Position - game.Players.LocalPlayer.Character.Torso.Position).magnitude
       if pvm >= 77  then
           if pvm <=84 then
               pv.PowerValue.Value = 95
              cam()
           
end
end
local lookthat = findClosestPart(game.Players.LocalPlayer.Character.Torso.Position)
local pvm = (lookthat.Position - game.Players.LocalPlayer.Character.Torso.Position).magnitude
if pvm >= 85  then
if pvm <=91 then
pv.PowerValue.Value = 100
cam()
               
       
end
end
end
end)
end)

local UIS = game:service('UserInputService')
UIS.InputBegan:connect(function(l)
if l.UserInputType == Enum.UserInputType.MouseButton1 then
isdoing = false
end
end)
end)

Tab1:Button("(X) Jump Everyone",function()
    local acceptableexploits = (is_synapse_function or KRNL_LOADED)
local x = {}
local t = game.Players.LocalPlayer
local z = t.Character["Head"]
local u = game:GetService("UserInputService")
if acceptableexploits then
e = false
u.InputBegan:connect(function(l, a)
   if l.KeyCode == Enum.KeyCode.X and not a then
       e = true
       repeat
for i,v in pairs(game.Players:GetPlayers()) do
   if v.Name ~= game.Players.LocalPlayer.Name then
       table.insert(x, v.Character["Left Leg"])
       local o = 0
       local f = 1
       
       firetouchinterest(v.Character["Left Leg"], z, o)
       wait(0.01)
       firetouchinterest(v.Character["Left Leg"], z, f)
   end
end
until e == false
end
end)

u.InputEnded:connect(function(l,a)
   if l.KeyCode == Enum.KeyCode.X and not a then
       e = false
       end
   end)
else
   return warn("Not supported for your executor.")
end

local CoreGui = game:GetService("StarterGui") -- Variable of StarterGui

CoreGui:SetCore("SendNotification", {
    -- Customizable
    Title = "When You Get The Ball",
    Text = "Press X",
    Duration = 2, -- Set the duration to how much you want this to stay
    -- More code in part 2
})
end)

Tab1:Button("(B) No Steal",function()
local u = game:service('UserInputService')
u.InputBegan:connect(function(a,l)
if a.KeyCode == Enum.KeyCode.B and not l then
game:service('Players').LocalPlayer.Character.Basketball.ToolTip:Destroy()
end
end)
local CoreGui = game:GetService("StarterGui") -- Variable of StarterGui

CoreGui:SetCore("SendNotification", {
    -- Customizable
    Title = "When You Get The Ball Press B",
    Text = "You Can't Shoot With This ONLY DUNK!",
    Duration = 2, -- Set the duration to how much you want this to stay
    -- More code in part 2
})
end)
Tab1:Button("Ball Size/Mag",function()
     while true do
                for _, v in pairs (game.workspace:GetDescendants())do
if v.Name == 'Handle' then 
v.Size = Vector3.new(6, 6, 6)
end
end
wait(1)
end
    end)
    
    
    Tab1:Button("Remove HeadRide Ankle Breaker ",function()
        local h = game:service('Players').LocalPlayer.Character.Humanoid
h:GetPropertyChangedSignal('PlatformStand'):Connect(function(ewo)
h.PlatformStand = false
end)
    end)
    
    Tab1:Button("(Z) Auto Guard",function()
        local tr = false
local Mouse = game.Players.LocalPlayer:GetMouse()

game:GetService("UserInputService").InputBegan:Connect(function(key, gpe)
   if key.KeyCode == Enum.KeyCode.Z and not gpe and tr == false then
           tr = true
           for i, v in pairs(game.Players:GetPlayers()) do
               local char = game.Players.LocalPlayer.Character
               if v.Name ~= char.Name and (v.Character.Torso.CFrame.p - char.Torso.CFrame.p).Magnitude < 25 then
                   while tr == true do
                       if v.Character.Torso.Velocity.magnitude > 0.5 and v.Character:FindFirstChild("Basketball") then
                           char.Humanoid:MoveTo(v.Character.Torso.CFrame.p + v.Character.Torso.Velocity.unit * 7)
                       elseif v.Character.Torso.Velocity.magnitude < 0.5 and v.Character:FindFirstChild("Basketball") then
                           char.Humanoid:MoveTo(v.Character.Torso.CFrame.p)
                       elseif not v.Character:FindFirstChild("Basketball") then
                           tr = false
                       end
                        task.wait()
                   end
               end
           end
       elseif key.KeyCode == Enum.KeyCode.Z and not gpe and tr == true then
           tr = false
       end
   end
)
    end)
    
    
    Tab1:Slider("Bypassed Block Extender",2,40,function(v)
   if not getgenv().MTAPIMutex then loadstring(game:HttpGet("https://raw.githubusercontent.com/KikoTheDon/MT-Api-v2/main/__source/mt-api%20v2.lua", true))() end

local plr = game.Players.LocalPlayer
local hook = nil
local enabled = false

plr.Character["Left Arm"]:AddPropertyEmulator("Size") -- fake size
plr.Character["Right Arm"]:AddPropertyEmulator("Size") -- fake size


        plr.Character["Left Arm"]:AddPropertyEmulator("Size") -- fake size
        plr.Character["Right Arm"]:AddPropertyEmulator("Size") -- fake size
        
        for i,v in pairs(getconnections(plr.Character["Left Arm"]:GetPropertyChangedSignal("Size"))) do
            v.Function = error
            v:Disable() -- disable property changed
        end
        for i,v in pairs(getconnections(plr.Character["Right Arm"]:GetPropertyChangedSignal("Size"))) do
            v.Function = error
            v:Disable() -- disable property changed
        end
				plr.Character['Left Arm'].Size = Vector3.new(1, (v), 1)
				plr.Character['Right Arm'].Size = Vector3.new(1, (v), 1)
			plr.Character["Right Arm"].Massless = true
        plr.Character["Left Arm"].Massless = true
        enabled = true
end)

 Tab1:Slider("Bypassed Hitbox Extender",2,100,function(v)
    if not getgenv().MTAPIMutex then loadstring(game:HttpGet("https://raw.githubusercontent.com/KikoTheDon/MT-Api-v2/main/__source/mt-api%20v2.lua", true))() end

local plr = game.Players.LocalPlayer
local hook = nil
local enabled = false

plr.Character["Left Arm"]:AddPropertyEmulator("Size") -- fake size
plr.Character["Right Arm"]:AddPropertyEmulator("Size") -- fake size


        plr.Character["Left Arm"]:AddPropertyEmulator("Size") -- fake size
        plr.Character["Right Arm"]:AddPropertyEmulator("Size") -- fake size
        
        for i,v in pairs(getconnections(plr.Character["Left Arm"]:GetPropertyChangedSignal("Size"))) do
            v.Function = error
            v:Disable() -- disable property changed
        end
        for i,v in pairs(getconnections(plr.Character["Right Arm"]:GetPropertyChangedSignal("Size"))) do
            v.Function = error
            v:Disable() -- disable property changed
        end
				plr.Character['Left Arm'].Size = Vector3.new((v), 1, 1)
				plr.Character['Right Arm'].Size = Vector3.new((v), 1, 1)
plr.Character["Right Arm"].Massless = true
        plr.Character["Left Arm"].Massless = true
				
 end)
 
Tab1:Button("(R) Bring Ball",function()
local UIS = game:GetService('UserInputService')
local plr = game.Players.LocalPlayer
local Char = plr.Character or plr.CharacterAded:Wait()
local Key = 'R'
UIS.InputBegan:Connect(function(Input, IsTyping)
if IsTyping then return end
local KeyPressed = Input.KeyCode
if KeyPressed == Enum.KeyCode[Key] then
game.Workspace.Map.Basketball.Handle.CFrame = Game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
end
end)
end)

Tab1:Slider("Slider",16,500,function(s)
    print(s)
end)

local Tab2 = Window:Tab("Misc",false)

Tab2:Label("Misc")

Tab2:Slider("Bypass Speed",16,120,function(v)
    if not getgenv().MTAPIMutex then if getgenv().MTAPIMutex~=nil then return end;local function a()if is_protosmasher_caller~=nil then return 0 end;if elysianexecute~=nil then return 1 end;if fullaccess~=nil then return 2 end;if Synapse~=nil then return 3 end;return 4 end;local function b()local c=a()if c==0 then return is_protosmasher_caller end;if c==1 or c==3 then return checkcaller end;if c==2 then return IsLevel7 end;return nil end;if a()==2 then error("mt-api: Exploit not supported")end;local d={}local e={}local f={}local g={}local h={}local i={}local j={}local k={}local function l()local m=a()local n=b()local o=getrawmetatable(game)if m==0 then make_writeable(o)elseif m==2 then fullaccess(o)else setreadonly(o,false)end;local p=o.__index;local q=o.__newindex;local r=o.__namecall;o.__index=newcclosure(function(s,t)if n()then return p(s,t)end;if d[s]and d[s][t]then local u=d[s][t]if u["IsCallback"]==true then return u["Value"](s)else return u["Value"]end end;if g[t]then local v=g[t]if v["IsCallback"]==true then return v["Value"](s)else return v["Value"]end end;if j[s]and j[s][t]then return k[s][t]end;return p(s,t)end)o.__newindex=newcclosure(function(w,x,y)if n()then return q(w,x,y)end;if e[w]and e[w][x]then local z=e[w][x]if z["Callback"]==nil then return else z["Callback"](w,y)return end end;if h[x]then local A=h[x]if A["Callback"]==nil then return else A["Callback"](w,y)return end end;if j[w]and j[w][x]then local B=j[w][x]if type(y)~=B["Type"]then error("bad argument #3 to '"..x.."' ("..B["Type"].." expected, got "..type(x)..")")end;k[w][x]=y;return end;return q(w,x,y)end)local C=isluau and isluau()or false;o.__namecall=newcclosure(function(D,...)local E={...}local F=C and getnamecallmethod()or table.remove(E)if n()then if F=="AddGetHook"then if#E<1 then error("mt-api: Invalid argument count")end;local G=E[1]local H=E[2]local I=E[3]if type(G)~="string"then error("mt-api: Invalid hook type")end;if not d[D]then d[D]={}end;if I==true and type(H)~="function"then error("mt-api: Invalid callback function")end;d[D][G]={Value=H,IsCallback=I}local J=function()d[D][G]=nil end;return{remove=J,Remove=J}end;if F=="AddGlobalGetHook"then local K=E[1]local L=E[2]local M=E[3]if type(K)~="string"then error("mt-api: Invalid hook type")end;if M==true and type(L)~="function"then error("mt-api: Invalid callback function")end;g[K]={Value=L,IsCallback=M}local N=function()g[K]=nil end;return{remove=N,Remove=N}end;if F=="AddSetHook"then if#E<1 then error("mt-api: Invalid argument count")end;local O=E[1]local P=E[2]if type(O)~="string"then error("mt-api: Invalid hook type")end;if not e[D]then e[D]={}end;if type(P)=="function"then e[D][O]={Callback=P}else e[D][O]={Callback=nil}end;local Q=function()e[D][O]=nil end;return{remove=Q,Remove=Q}end;if F=="AddGlobalSetHook"then if#E<1 then error("mt-api: Invalid argument count")end;local R=E[1]local S=E[2]if type(R)~="string"then error("mt-api: Invalid hook type")end;if type(S)=="function"then h[R]={Callback=S}else h[R]={Callback=nil}end;local T=function()h[R]=nil end;return{remove=T,Remove=T}end;if F=="AddCallHook"then if#E<2 then error("mt-api: Invalid argument count")end;local U=E[1]local V=E[2]if type(U)~="string"then error("mt-api: Invalid hook type")end;if type(V)~="function"then error("mt-api: Invalid argument #2 (not function)")end;if not f[D]then f[D]={}end;f[D][U]={Callback=V}local W=function()f[D][U]=nil end;return{remove=W,Remove=W}end;if F=="AddGlobalCallHook"then if#E<2 then error("mt-api: Invalid argument count")end;local X=E[1]local Y=E[2]if type(X)~="string"then error("mt-api: Invalid hook type")end;if type(Y)~="function"then error("mt-api: Invalid argument #2 (not function)")end;i[X]={Callback=Y}local Z=function()i[X]=nil end;return{remove=Z,Remove=Z}end;if F=="AddPropertyEmulator"then if#E<1 then error("mt-api: Invalid argument count")end;local _=E[1]if type(_)~="string"then error("mt-api: Invalid hook type")end;local a0=p(D,_)local a1=type(a0)if not j[D]then j[D]={}end;if not k[D]then k[D]={}end;j[D][_]={Type=a1}k[D][_]=p(D,_)local a2=function()j[D][_]=nil;k[D][_]=nil end;return{remove=a2,Remove=a2}end;return r(D,...)end;if f[D]and f[D][F]then local a3=f[D][F]return a3["Callback"](p(D,F),unpack(E))end;if i[F]then local a4=i[F]return a4["Callback"](D,p(D,F),unpack(E))end;return r(D,...)end)if m==0 then make_readonly(o)elseif m==2 then else setreadonly(o,true)end end;l()getgenv().MTAPIMutex=true end
		game.Players.LocalPlayer.Character.Humanoid:AddPropertyEmulator("WalkSpeed")
		game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (v)
end)

Tab2:Slider("Bypass JumpPower",50,80,function(v)
    if not getgenv().MTAPIMutex then if getgenv().MTAPIMutex~=nil then return end;local function a()if is_protosmasher_caller~=nil then return 0 end;if elysianexecute~=nil then return 1 end;if fullaccess~=nil then return 2 end;if Synapse~=nil then return 3 end;return 4 end;local function b()local c=a()if c==0 then return is_protosmasher_caller end;if c==1 or c==3 then return checkcaller end;if c==2 then return IsLevel7 end;return nil end;if a()==2 then error("mt-api: Exploit not supported")end;local d={}local e={}local f={}local g={}local h={}local i={}local j={}local k={}local function l()local m=a()local n=b()local o=getrawmetatable(game)if m==0 then make_writeable(o)elseif m==2 then fullaccess(o)else setreadonly(o,false)end;local p=o.__index;local q=o.__newindex;local r=o.__namecall;o.__index=newcclosure(function(s,t)if n()then return p(s,t)end;if d[s]and d[s][t]then local u=d[s][t]if u["IsCallback"]==true then return u["Value"](s)else return u["Value"]end end;if g[t]then local v=g[t]if v["IsCallback"]==true then return v["Value"](s)else return v["Value"]end end;if j[s]and j[s][t]then return k[s][t]end;return p(s,t)end)o.__newindex=newcclosure(function(w,x,y)if n()then return q(w,x,y)end;if e[w]and e[w][x]then local z=e[w][x]if z["Callback"]==nil then return else z["Callback"](w,y)return end end;if h[x]then local A=h[x]if A["Callback"]==nil then return else A["Callback"](w,y)return end end;if j[w]and j[w][x]then local B=j[w][x]if type(y)~=B["Type"]then error("bad argument #3 to '"..x.."' ("..B["Type"].." expected, got "..type(x)..")")end;k[w][x]=y;return end;return q(w,x,y)end)local C=isluau and isluau()or false;o.__namecall=newcclosure(function(D,...)local E={...}local F=C and getnamecallmethod()or table.remove(E)if n()then if F=="AddGetHook"then if#E<1 then error("mt-api: Invalid argument count")end;local G=E[1]local H=E[2]local I=E[3]if type(G)~="string"then error("mt-api: Invalid hook type")end;if not d[D]then d[D]={}end;if I==true and type(H)~="function"then error("mt-api: Invalid callback function")end;d[D][G]={Value=H,IsCallback=I}local J=function()d[D][G]=nil end;return{remove=J,Remove=J}end;if F=="AddGlobalGetHook"then local K=E[1]local L=E[2]local M=E[3]if type(K)~="string"then error("mt-api: Invalid hook type")end;if M==true and type(L)~="function"then error("mt-api: Invalid callback function")end;g[K]={Value=L,IsCallback=M}local N=function()g[K]=nil end;return{remove=N,Remove=N}end;if F=="AddSetHook"then if#E<1 then error("mt-api: Invalid argument count")end;local O=E[1]local P=E[2]if type(O)~="string"then error("mt-api: Invalid hook type")end;if not e[D]then e[D]={}end;if type(P)=="function"then e[D][O]={Callback=P}else e[D][O]={Callback=nil}end;local Q=function()e[D][O]=nil end;return{remove=Q,Remove=Q}end;if F=="AddGlobalSetHook"then if#E<1 then error("mt-api: Invalid argument count")end;local R=E[1]local S=E[2]if type(R)~="string"then error("mt-api: Invalid hook type")end;if type(S)=="function"then h[R]={Callback=S}else h[R]={Callback=nil}end;local T=function()h[R]=nil end;return{remove=T,Remove=T}end;if F=="AddCallHook"then if#E<2 then error("mt-api: Invalid argument count")end;local U=E[1]local V=E[2]if type(U)~="string"then error("mt-api: Invalid hook type")end;if type(V)~="function"then error("mt-api: Invalid argument #2 (not function)")end;if not f[D]then f[D]={}end;f[D][U]={Callback=V}local W=function()f[D][U]=nil end;return{remove=W,Remove=W}end;if F=="AddGlobalCallHook"then if#E<2 then error("mt-api: Invalid argument count")end;local X=E[1]local Y=E[2]if type(X)~="string"then error("mt-api: Invalid hook type")end;if type(Y)~="function"then error("mt-api: Invalid argument #2 (not function)")end;i[X]={Callback=Y}local Z=function()i[X]=nil end;return{remove=Z,Remove=Z}end;if F=="AddPropertyEmulator"then if#E<1 then error("mt-api: Invalid argument count")end;local _=E[1]if type(_)~="string"then error("mt-api: Invalid hook type")end;local a0=p(D,_)local a1=type(a0)if not j[D]then j[D]={}end;if not k[D]then k[D]={}end;j[D][_]={Type=a1}k[D][_]=p(D,_)local a2=function()j[D][_]=nil;k[D][_]=nil end;return{remove=a2,Remove=a2}end;return r(D,...)end;if f[D]and f[D][F]then local a3=f[D][F]return a3["Callback"](p(D,F),unpack(E))end;if i[F]then local a4=i[F]return a4["Callback"](D,p(D,F),unpack(E))end;return r(D,...)end)if m==0 then make_readonly(o)elseif m==2 then else setreadonly(o,true)end end;l()getgenv().MTAPIMutex=true end
		game.Players.LocalPlayer.Character.Humanoid:AddPropertyEmulator("JumpPower")
		game.Players.LocalPlayer.Character.Humanoid.JumpPower = (v)
end)

Tab2:Button("Opposite Team Esp",function()
    
local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local CurrentCamera = workspace.CurrentCamera
local worldToViewportPoint = CurrentCamera.worldToViewportPoint

local HeadOff = Vector3.new(0, 0.5, 0)
local LegOff = Vector3.new(0,3,0)

for i,v in pairs(game.Players:GetChildren()) do
    local BoxOutline = Drawing.new("Square")
    BoxOutline.Visible = false
    BoxOutline.Color = Color3.new(0,0,0)
    BoxOutline.Thickness = 3
    BoxOutline.Transparency = 1
    BoxOutline.Filled = false

    local Box = Drawing.new("Square")
    Box.Visible = false
    Box.Color = Color3.new(1,1,1)
    Box.Thickness = 1
    Box.Transparency = 1
    Box.Filled = false

    function boxesp()
        game:GetService("RunService").RenderStepped:Connect(function()
            if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

                local RootPart = v.Character.HumanoidRootPart
                local Head = v.Character.Head
                local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
                local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + HeadOff)
                local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)

                if onScreen then
                    BoxOutline.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                    BoxOutline.Position = Vector2.new(RootPosition.X - BoxOutline.Size.X / 2, RootPosition.Y - BoxOutline.Size.Y / 2)
                    BoxOutline.Visible = true

                    Box.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                    Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                    Box.Visible = true

                    if v.TeamColor == lplr.TeamColor then
                        BoxOutline.Visible = false
                        Box.Visible = false
                    else
                        BoxOutline.Visible = true
                        Box.Visible = true
                    end

                else
                    BoxOutline.Visible = false
                    Box.Visible = false
                end
            else
                BoxOutline.Visible = false
                Box.Visible = false
            end
        end)
    end
    coroutine.wrap(boxesp)()
end

game.Players.PlayerAdded:Connect(function(v)
    local BoxOutline = Drawing.new("Square")
    BoxOutline.Visible = false
    BoxOutline.Color = Color3.new(0,0,0)
    BoxOutline.Thickness = 3
    BoxOutline.Transparency = 1
    BoxOutline.Filled = false

    local Box = Drawing.new("Square")
    Box.Visible = false
    Box.Color = Color3.new(1,1,1)
    Box.Thickness = 1
    Box.Transparency = 1
    Box.Filled = false

    function boxesp()
        game:GetService("RunService").RenderStepped:Connect(function()
            if v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

                local RootPart = v.Character.HumanoidRootPart
                local Head = v.Character.Head
                local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
                local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + HeadOff)
                local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)

                if onScreen then
                    BoxOutline.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                    BoxOutline.Position = Vector2.new(RootPosition.X - BoxOutline.Size.X / 2, RootPosition.Y - BoxOutline.Size.Y / 2)
                    BoxOutline.Visible = true

                    Box.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                    Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                    Box.Visible = true

                    if v.TeamColor == lplr.TeamColor then
                        BoxOutline.Visible = false
                        Box.Visible = false
                    else
                        BoxOutline.Visible = true
                        Box.Visible = true
                    end

                else
                    BoxOutline.Visible = false
                    Box.Visible = false
                end
            else
                BoxOutline.Visible = false
                Box.Visible = false
            end
        end)
    end
    coroutine.wrap(boxesp)()
end)
end)
    
Tab2:Button("Double Jump",function()
    local UserInputService = game:GetService("UserInputService")
local localPlayer = game.Players.LocalPlayer
local character
local humanoid
local canDoubleJump = false
local hasDoubleJumped = false
local oldPower
local TIME_BETWEEN_JUMPS = 0.2
local DOUBLE_JUMP_POWER_MULTIPLIER = 1
function onJumpRequest()
    if not character or not humanoid or not character:IsDescendantOf(workspace) or
    humanoid:GetState() == Enum.HumanoidStateType.Dead then
        return
    end
 
    if canDoubleJump and not hasDoubleJumped then
        hasDoubleJumped = true
        humanoid.JumpPower = oldPower * DOUBLE_JUMP_POWER_MULTIPLIER
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
end
local function characterAdded(newCharacter)
    character = newCharacter
    humanoid = newCharacter:WaitForChild("Humanoid")
    hasDoubleJumped = false
    canDoubleJump = false
    oldPower = humanoid.JumpPower
 
    humanoid.StateChanged:connect(function(old, new)
        if new == Enum.HumanoidStateType.Landed then
            canDoubleJump = false
            hasDoubleJumped = false
            humanoid.JumpPower = oldPower
        elseif new == Enum.HumanoidStateType.Freefall then
            wait(TIME_BETWEEN_JUMPS)
            canDoubleJump = true
        end
    end)
end
if localPlayer.Character then
    characterAdded(localPlayer.Character)
end

localPlayer.CharacterAdded:connect(characterAdded)
UserInputService.JumpRequest:connect(onJumpRequest)
end)

Tab2:Button("Anti bypass",function()
    
    
    end)
